Для решения задачи будем использовать паттерн Visitor.
Так как имеем стабильную систему типов, то будем ипользовать динамического визитора, который не требует введения нового метода в нашу систему типов.
1. Создадим абстрактный класс [DocumentPartConverter](https://github.com/HannaZhuravskaya/NET.2018.Zhuravskaya/blob/master/NET1.A.2018.Zhuravskaya.21/No5.Solution/DocumentPartConverter.cs) с одним публичным методом DynamicVisit.
2. Добавляем в него абстрактные protected методы Visit, принимающие конкретную реализацию интерфейса [DocumentPart](https://github.com/HannaZhuravskaya/NET.2018.Zhuravskaya/blob/master/NET1.A.2018.Zhuravskaya.21/No5.Solution/DocumentPart.cs).
3. Создадим классы [DocumentPartToPlainText](https://github.com/HannaZhuravskaya/NET.2018.Zhuravskaya/blob/master/NET1.A.2018.Zhuravskaya.21/No5.Solution/DocumentPartConverterImplementations/DocumentPartToPlainText.cs), [DocumentPartToLaTeX](https://github.com/HannaZhuravskaya/NET.2018.Zhuravskaya/blob/master/NET1.A.2018.Zhuravskaya.21/No5.Solution/DocumentPartConverterImplementations/DocumentPartToLaTeX.cs), [DocumentPartToHtml](https://github.com/HannaZhuravskaya/NET.2018.Zhuravskaya/blob/master/NET1.A.2018.Zhuravskaya.21/No5.Solution/DocumentPartConverterImplementations/DocumentPartToHtml.cs), имплементирующие [DocumentPartConverter](https://github.com/HannaZhuravskaya/NET.2018.Zhuravskaya/blob/master/NET1.A.2018.Zhuravskaya.21/No5.Solution/DocumentPartConverter.cs).

Таким образом, при появлении нового формата, в который требуется конвертировать документ, будет добавляться новая имплементация класса [DocumentPartConverter](https://github.com/HannaZhuravskaya/NET.2018.Zhuravskaya/blob/master/NET1.A.2018.Zhuravskaya.21/No5.Solution/DocumentPartConverter.cs), а система типов изменяться не будет. 
